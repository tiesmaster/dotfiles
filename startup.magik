_block
	_local bv << !current_package![:bv] << gis_program_manager.databases[:bag]
	_if bv _is _unset _then _leave _endif
	
	!current_package![:bvbo] << bv.collection(:bag_verblijfsobject)
	!current_package![:bip] << bv.collection(:bag!import_progress)
	!current_package![:ber] << bv.collection(:bag!error_record)
_endblock
$

_global open_oracle <<
_proc @ open_oracle()
	sw_database.new(:oracle, _unset, :initial_soc_name, :oracle)
_endproc
$

_global reload_module <<
_proc @ reload_module(m)
	_handling sw_module_redefining_module _with _proc() _endproc
	_handling sw_module_already_loaded_same_version _with _proc() _endproc

	_handling patch_loading_done _with _proc() _endproc
	_handling patch_dir_loading _with _proc() _endproc
	_handling patch_seeking _with _proc() _endproc

	_handling exemplar_already_exists _with _proc() _endproc
	_handling removing_exemplar _with _proc() _endproc
	_handling global_changing_nature _with _proc() _endproc
	_handling pseudo_slot_added _with _proc() _endproc
	_handling conflict_methods _with _proc() _endproc

	_handling condition_exists _with _proc() _endproc

	_dynamic !output! << internal_text_output_stream.new()
	_protect
		pragma_monitor.stop_monitor()
		sw_module_manager.load_module(m, _unset, :force_reload?, _true)
	_protection
		pragma_monitor.start_monitor()
	_endprotect
_endproc
$
_global reload_modules <<
_proc @ reload_modules(mods)
	t0 << date_time.now()
	_for m _over mods.fast_elements()
	_loop
		reload_module(m)
	_endloop
	write("TIME: ", date_time.now() - t0)
_endproc
$

_block
	# poor man's implementation for detecting building
	_if system.getenv("EMACSDATA") _isnt _unset
	_then
		# open_oracle()
	_endif
_endblock
$
