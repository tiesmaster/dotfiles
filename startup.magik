_block
	_local bv << !current_package![:bv] << gis_program_manager.databases[:bag]
	_if bv _is _unset _then _leave _endif
	
	!current_package![:bvbo] << bv.collection(:bag_verblijfsobject)
	!current_package![:bip] << bv.collection(:bag!import_progress)
	!current_package![:ber] << bv.collection(:bag!error_record)
_endblock
$

_global open_oracle <<
_proc @ open_oracle()
	sw_database.new(:oracle, _unset, :initial_soc_name, :oracle)
_endproc
$

_global dummy_proc <<
_proc @ dummy_proc()
_endproc
$

def_slotted_exemplar(:ignore_newline_output_stream_decorator,
{
	{:inner_stream, _unset},
	{:empty_line?, _true}

}, :internal_text_output_stream)
$

_method ignore_newline_output_stream_decorator.new(inner_stream)
	>> _clone.init(inner_stream)
_endmethod
$

_method ignore_newline_output_stream_decorator.init(inner_stream)
	.inner_stream << inner_stream
	>> _self
_endmethod
$

_method ignore_newline_output_stream_decorator.put_charvec(cv,_optional start, length)
	_if cv <> ""
	_then
		.empty_line? << _false
	_endif
	>> .inner_stream.put_charvec(cv, start, length)
_endmethod
$

_method ignore_newline_output_stream_decorator.newline()
	_if _not .empty_line?
	_then
		.empty_line? << _true
		_return .inner_stream.newline()
	_endif
_endmethod
$

_global disable_magik_rep_messages <<
_proc @ disable_magik_rep_messages(lang)
	# let the message_accessor populate its patch table if not done yet
	magik_rep.message_accessor.patched_messages.at_or_new_if_absent(lang, equality_hash_table)

	orig_patch_table << magik_rep.message_accessor.patched_messages[lang].copy()
	patched << magik_rep.message_accessor.patched_messages[lang]

	patched[:loading] << ""
	patched[:loading_line] << ""
	patched[:define_variable] << ""
	patched[:define_method] << ""
	patched[:redefine_method] << ""
	patched[:supersede_method] << ""
	patched[:running] << ""
	patched[:compiled] << ""

	magik_rep.message_accessor.clear_cache()

	>> orig_patch_table
_endproc
$

_global reenable_magik_rep_messages <<
_proc @ reenable_magik_rep_messages(lang, orig_patch_table)
	magik_rep.message_accessor.patched_messages[lang] << orig_patch_table
	magik_rep.message_accessor.clear_cache()
_endproc
$

_global reload_module <<
_proc @ reload_module(m)
	_handling sw_module_redefining_module _with dummy_proc
	_handling sw_module_already_loaded_same_version _with dummy_proc

	_handling patch_seeking _with dummy_proc
	_handling patch_dir_loading _with dummy_proc
	_handling patch_loading_done _with dummy_proc

	_handling exemplar_already_exists _with dummy_proc
	_handling removing_exemplar _with dummy_proc
	_handling global_changing_nature _with dummy_proc
	_handling pseudo_slot_added _with dummy_proc
	_handling conflict_methods _with dummy_proc

	_handling condition_exists _with dummy_proc

	_dynamic !output! << ignore_newline_output_stream_decorator.new(!output!)
	_protect
		lang << !current_languages!.an_element()
		orig_patch_table << disable_magik_rep_messages(lang)
		pragma_monitor.stop_monitor()

		sw_module_manager.load_module(m, _unset, :force_reload?, _true)
	_protection
		reenable_magik_rep_messages(lang, orig_patch_table)
		pragma_monitor.start_monitor()
	_endprotect
_endproc
$

_global reload_modules <<
_proc @ reload_modules(mods)
	t0 << date_time.now()

	write("======> RELOADING MODULES: ", mods.join_as_strings(", "))
	_for m _over mods.fast_elements()
	_loop
		reload_module(m)
	_endloop
	write("TIME: ", date_time.now() - t0)
_endproc
$

_block
	# poor man's implementation for detecting building
	_if system.getenv("EMACSDATA") _isnt _unset
	_then
		# open_oracle()
	_endif
_endblock
$
