_block
	_local bv << !current_package![:bv] << gis_program_manager.databases[:bag]
	_if bv _is _unset _then _leave _endif
	
	!current_package![:bvbo] << bv.collection(:bag_verblijfsobject)
	!current_package![:bip] << bv.collection(:bag!import_progress)
	!current_package![:ber] << bv.collection(:bag!error_record)
_endblock
$

_global open_prd <<
_proc @ open_prd()
	open_database(system.getenv("SW_ACE_DB_DIR"))
_endproc
$

_global open_oracle <<
_proc @ open_oracle()
	sw_database.new(:oracle, _unset, :initial_soc_name, :oracle)
_endproc
$

_global load_richtingen_kaart_module <<
_proc @ load_richtingen_kaart_module()
	_if _not sw_module_manager.module_is_defined?(:ls_richtingen)
	_then
		smallworld_product.add_product(system.pathname_down(system.getenv("ENECO_ROOT"), "src", "richtingen_kaart"))
	_endif
	_if _not sw_module_manager.module(:ls_richtingen_dev).loaded?
	_then
		sw_module_manager.load_module(:ls_richtingen_dev, _unset, :update_image?, _false)
	_endif
_endproc
$

_global save_image <<
_proc @ save_image(image_name)
	images_path << system.pathname_up(system.verbatim_image_name)
	redirector_file << system.pathname_down(images_path, image_name + ".msf")
	image_file << system.pathname_down(images_path, "main", image_name + ".msf")
	save_image_startup(image_file, :join?, _false, :join, _unset, :redirection_file, redirector_file)
_endproc
$

_global dummy_proc <<
_proc @ dummy_proc()
_endproc
$

_global run_if_dsfile_is_absent<<
_proc @ run_if_file_is_absent(ds_filename, a_proc)
	ace_db_dir << system.getenv("SW_ACE_DB_DIR")
	dsfile << system.pathname_down(ace_db_dir, ds_filename)
	_if _not system.file_exists?(dsfile)
	_then
		ds_environment.init()
		a_proc(ace_db_dir)
	_endif
_endproc
$

_global open_eneco_database<<
_proc @ open_eneco_database()
	 ds_environment.concurrency_mode << :singleuser
	 run_if_dsfile_is_absent("scrapbook.ds", _proc(ace_db_dir) scrapbook_view.new_database(_unset, ace_db_dir) _endproc)
	 run_if_dsfile_is_absent("roos_ace.ds", _proc(ace_db_dir) roos_ace_view.create(ace_db_dir) _endproc)

	 # this prevents annoying UI stuff
	 smallworld_product.startup_options[:interactive?] << _false
	 open_database()
_endproc
$

_global build_open_image<<
_proc @ build_open_image()
	open_eneco_database()
	save_image("open")
_endproc
$

_global build_kaart_image <<
_proc @ build_kaart_image()
	# smallworld_product.application_procedures.empty()
	smallworld_product.startup_options[:ace] << "Verzamelkaart Beheer"
	load_richtingen_kaart_module()
	save_image("kaart")
_endproc
$

_block
	_handling exemplar_already_exists _with _proc() _endproc

	def_slotted_exemplar(:ignore_newline_output_stream_decorator,
	{
		{:inner_stream, _unset},
		{:empty_line?, _true}

	}, :internal_text_output_stream)
_endblock
$

_method ignore_newline_output_stream_decorator.new(inner_stream)
	>> _clone.init(inner_stream)
_endmethod
$

_method ignore_newline_output_stream_decorator.init(inner_stream)
	.inner_stream << inner_stream
	>> _self
_endmethod
$

_method ignore_newline_output_stream_decorator.put_charvec(cv,_optional start, length)
	_if cv <> ""
	_then
		.empty_line? << _false
	_endif
	>> .inner_stream.put_charvec(cv, start, length)
_endmethod
$

_method ignore_newline_output_stream_decorator.newline()
	_if _not .empty_line?
	_then
		.empty_line? << _true
		_return .inner_stream.newline()
	_endif
_endmethod
$

_global disable_magik_rep_messages <<
_proc @ disable_magik_rep_messages(lang)
	# let the message_accessor populate its patch table if not done yet
	magik_rep.message_accessor.patched_messages.at_or_new_if_absent(lang, equality_hash_table)

	orig_patch_table << magik_rep.message_accessor.patched_messages[lang].copy()
	patched << magik_rep.message_accessor.patched_messages[lang]

	patched[:loading] << ""
	patched[:loading_line] << ""
	patched[:define_variable] << ""
	patched[:define_method] << ""
	patched[:redefine_method] << ""
	patched[:supersede_method] << ""
	patched[:running] << ""
	patched[:compiled] << ""

	magik_rep.message_accessor.clear_cache()

	>> orig_patch_table
_endproc
$

_global reenable_magik_rep_messages <<
_proc @ reenable_magik_rep_messages(lang, orig_patch_table)
	magik_rep.message_accessor.patched_messages[lang] << orig_patch_table
	magik_rep.message_accessor.clear_cache()
_endproc
$

_global decorate_def_slotted_exemplar <<
_proc @ decorate_def_slotted_exemplar()
	dse << @def_slotted_exemplar
	_local orig_dse_proc << dse.value
	@def_slotted_exemplar.sys!value <<
		_proc @decorated_def_slotted_exemplar (name,slots,_optional parents)
			_import orig_dse_proc

			remex(name)
			orig_dse_proc(name, slots, parents)
		_endproc
	>> orig_dse_proc
_endproc
$

_global revert_def_slotted_exemplar <<
_proc @ revert_def_slotted_exemplar(orig_dse_proc)
	@def_slotted_exemplar.sys!value << orig_dse_proc
_endproc
$

_global reload_module <<
_proc @ reload_module(m)
	_handling sw_module_redefining_module _with dummy_proc
	_handling sw_module_already_loaded_same_version _with dummy_proc

	_handling patch_seeking _with dummy_proc
	_handling patch_dir_loading _with dummy_proc
	_handling patch_loading_done _with dummy_proc

	_handling exemplar_already_exists _with dummy_proc
	_handling removing_exemplar _with dummy_proc
	_handling global_changing_nature _with dummy_proc
	_handling pseudo_slot_added _with dummy_proc
	_handling conflict_methods _with dummy_proc

	_handling condition_exists _with dummy_proc

	_dynamic !output! << ignore_newline_output_stream_decorator.new(!output!)
	_protect
		lang << !current_languages!.an_element()
		orig_patch_table << disable_magik_rep_messages(lang)
		orig_def_slotted_exemplar << decorate_def_slotted_exemplar()
		pragma_monitor.stop_monitor()

		sw_module_manager.load_module(m, _unset,
			:force_reload?, _true,
			:update_image?, _false)
	_protection
		reenable_magik_rep_messages(lang, orig_patch_table)
		revert_def_slotted_exemplar(orig_def_slotted_exemplar)
		pragma_monitor.start_monitor()
	_endprotect
_endproc
$

_global reload_modules <<
_proc @ reload_modules(mods)
	t0 << date_time.now()

	write("======> RELOADING MODULES: ", mods.join_as_strings(", "))
	_for m _over mods.fast_elements()
	_loop
		reload_module(m)
	_endloop
	write("TIME: ", date_time.now() - t0)
_endproc
$

_global setup_quick_import <<
_proc @ setup_quick_import()
	package(:bag)[:cli].xml_extract_path << "t:\rw\bag\xml_extract\"
	package(:bag)[:cli].verify_zipfile? << _false
	package(:bag)[:cli].disable_make_geometry_methods()
	package(:bag)[:cli].unregister_post_process_task(package(:bag)[:qa_text_runner])
	package(:bag)[:cli].unregister_post_process_task(package(:bag)[:generate_vbo_lokatie])
	package(:bag)[:cli].unregister_post_process_task(package(:bag)[:generate_wpl_ligging_groot])
	package(:bag)[:cli].unregister_post_process_task(package(:bag)[:generate_gemeente_geometry])
_endproc
$

_global time <<
_proc @ time(proc_to_profile)
	_protect
		t0 << date_time.now()
		proc_to_profile()
	_protection
		write(date_time.now() - t0)
	_endprotect
_endproc
$

_block
	# recompile the startup file, if it's not already present and
	# up to date (load_file() doesn't recompile :S:S:S:S::S)
	# NOTE: this is keep smallworld much less verbose

	# FIXME: retrieving the correct magikc file fixes recursion,
	# but we actually don't want our %TEMP%\Tties2236q0 to get compiled...
	_local magikc_file << magik_rep.sys!perform(:compiled_file_for_source|()|, !hack_file!)
	_if _not system.file_exists?(magikc_file) _orif
   		    (file_status.new(!hack_file!).modify_time >
		     file_status.new(magikc_file).modify_time)

	_then
		compile_file(!hack_file!)
	_endif
_endblock
$
