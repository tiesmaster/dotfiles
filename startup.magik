#% text_encoding = iso8859_1

_package user
$

####################   EGIS SHORTCUTS   ############################################################

_global kv << gis_program_manager.databases[:kabels]
$

####################   GENERIC SETTINGS   ##########################################################

_block
	!snapshot_traceback?! << _true
	system.sys!set_c_trace("msfgc", 0)
_endblock
$

####################   MAP UTILS   #################################################################

_global goto <<
_proc @ goto(an_rwo)
  appl().goto(an_rwo)
  appl().main_view.roos_wait_till_refresh_finished()
  an_rwo.bdraw()
_endproc
$

_global go_home <<
_proc @ go_home()
	appl().goto(coordinate.new(91538105, 434308419))
_endproc
$

####################   PROFILING UTILS   ###########################################################

_global time <<
_proc @ time(proc_to_profile)
	_protect
		t0 << date_time.now()
		proc_to_profile()
	_protection
		write(date_time.now() - t0)
	_endprotect
_endproc
$

####################   DS UTILS   ##################################################################

_method gis_ds_view.revert()
	 _self.rollback()
	_self.align()
_endmethod
$

_global create_working_top_template <<
_proc @ create_working_top_template(v)
	view_directory << v.searchpath.an_element()
	_if (i << view_directory.index_of_seq("::")) _isnt _unset
	_then
		view_directory << view_directory.slice_to_end(i+2)
	_endif
	working_top_template_dir << system.pathname_down(view_directory, "working_top.template")
	_if _not system.file_exists?(working_top_template_dir)
	_then
		system.mkdir(working_top_template_dir)
		v.spawn(:wtop, _false, working_top_template_dir)
		v.down(:wtop)
		v.make_working_top()
	_endif
_endproc
$

_global down_wt <<
_proc @ down_wt(v, wt_index_string)
	view_directory << v.searchpath.an_element()
	working_top_dir << system.pathname_down(view_directory, "working_top." + wt_index_string)
	v.searchpath << v.searchpath.new_appending(working_top_dir)
	v.down(:wtop)
	v.switch(:write)
_endproc
$

_global compress_file <<
_proc @ compress_file(f)
	_if system.file_exists?(f + ".compress")
	_then
		write("ERROR: target file already exists")
		_return _false
	_endif
	_if _not sw_module_manager.module_is_loaded?(:ds_transfer)
	_then
		sw_module_manager.load_module(:ds_transfer)
	_endif
	_if _not ds_environment.c_is_initialised?
	_then
		ds_environment.init()
	_endif
	(ds_filename, ds_file_path) << system.pathname_components(f)

	!current_package![:ds_transfer].run(
		:searchpath, {"su_file::" + ds_file_path},
		:from_ds_file, ds_filename,

		:directory, ds_file_path,
		:to_ds_file, ds_filename + ".compress",

		:target_concurrency_mode, :singleuser_nf,

		:alternatives, {:only, "|"},
		:checkpoints, {:only},
		:pg_report?, _true)
_endproc
$

####################   RELOAD MODULES   ############################################################

_global dummy_proc <<
_proc @ dummy_proc()
_endproc
$

_block
	_handling exemplar_already_exists _with _proc() _endproc

	def_slotted_exemplar(:ignore_newline_output_stream_decorator,
	{
		{:inner_stream, _unset},
		{:empty_line?, _true}

	}, :internal_text_output_stream)
_endblock
$

_method ignore_newline_output_stream_decorator.new(inner_stream)
	>> _clone.init(inner_stream)
_endmethod
$

_method ignore_newline_output_stream_decorator.init(inner_stream)
	.inner_stream << inner_stream
	>> _self
_endmethod
$

_method ignore_newline_output_stream_decorator.put_charvec(cv,_optional start, length)
	_if cv <> ""
	_then
		.empty_line? << _false
	_endif
	>> .inner_stream.put_charvec(cv, start, length)
_endmethod
$

_method ignore_newline_output_stream_decorator.newline()
	_if _not .empty_line?
	_then
		.empty_line? << _true
		_return .inner_stream.newline()
	_endif
_endmethod
$

_global disable_magik_rep_messages <<
_proc @ disable_magik_rep_messages(lang)
	# let the message_accessor populate its patch table if not done yet
	magik_rep.message_accessor.patched_messages.at_or_new_if_absent(lang, equality_hash_table)

	orig_patch_table << magik_rep.message_accessor.patched_messages[lang].copy()
	patched << magik_rep.message_accessor.patched_messages[lang]

	patched[:loading] << ""
	patched[:loading_line] << ""
	patched[:define_variable] << ""
	patched[:define_method] << ""
	patched[:redefine_method] << ""
	patched[:supersede_method] << ""
	patched[:running] << ""
	patched[:compiled] << ""

	magik_rep.message_accessor.clear_cache()

	>> orig_patch_table
_endproc
$

_global reenable_magik_rep_messages <<
_proc @ reenable_magik_rep_messages(lang, orig_patch_table)
	magik_rep.message_accessor.patched_messages[lang] << orig_patch_table
	magik_rep.message_accessor.clear_cache()
_endproc
$

_global decorate_def_slotted_exemplar <<
_proc @ decorate_def_slotted_exemplar()
	dse << @def_slotted_exemplar
	_local orig_dse_proc << dse.value
	@def_slotted_exemplar.sys!value <<
		_proc @decorated_def_slotted_exemplar (name,slots,_optional parents)
			_import orig_dse_proc

			remex(name)
			orig_dse_proc(name, slots, parents)
		_endproc
	>> orig_dse_proc
_endproc
$

_global revert_def_slotted_exemplar <<
_proc @ revert_def_slotted_exemplar(orig_dse_proc)
	@def_slotted_exemplar.sys!value << orig_dse_proc
_endproc
$

_global reload_module <<
_proc @ reload_module(m)
	_handling sw_module_redefining_module _with dummy_proc
	_handling sw_module_already_loaded_same_version _with dummy_proc

	_handling patch_seeking _with dummy_proc
	_handling patch_dir_loading _with dummy_proc
	_handling patch_loading_done _with dummy_proc

	_handling exemplar_already_exists _with dummy_proc
	_handling removing_exemplar _with dummy_proc
	_handling global_changing_nature _with dummy_proc
	_handling pseudo_slot_added _with dummy_proc
	_handling conflict_methods _with dummy_proc

	_handling condition_exists _with dummy_proc

	_dynamic !output! << ignore_newline_output_stream_decorator.new(!output!)
	_dynamic !global_auto_declare?! << _false
	_protect
		lang << !current_languages!.an_element()
		orig_patch_table << disable_magik_rep_messages(lang)
		orig_def_slotted_exemplar << decorate_def_slotted_exemplar()
		pragma_monitor.stop_monitor()

		sw_module_manager.load_module(m, _unset,
			:force_reload?, _true,
			:update_image?, _false)
	_protection
		reenable_magik_rep_messages(lang, orig_patch_table)
		revert_def_slotted_exemplar(orig_def_slotted_exemplar)
		pragma_monitor.start_monitor()
	_endprotect
_endproc
$

_global reload_modules <<
_proc @ reload_modules(mods)
	t0 << date_time.now()

	write("======> RELOADING MODULES: ", mods.join_as_strings(", "))
	_for m _over mods.fast_elements()
	_loop
		reload_module(m)
	_endloop
	write("TIME: ", date_time.now() - t0)
_endproc
$

####################   COMPILE STARTUP.MAGIK   #####################################################

_block
	# NOTE: These don't end up like you expect them to be,
	# eg. !hack_file! supposes to be the file in %TEMP%, if you use
	# F2-b, but it becomes the file from load_file/compile_file(),
	# if that's invoked somewhere above. !compiler_file! will
	# always be what !hack_file! supposes to be, while
	# !source_file! is the only one which is completely as
	# expected: the file that's the original source file.

	# write("!source_file!, !hack_file!, and !compiler_file!:")
	# write(%tab, "!source_file!: ", !source_file!)
	# write(%tab, "!hack_file!: ", !hack_file!)
	# write(%tab, "!compiler_file!: ", !compiler_file!)

	# NOTE: magik_rep.load_cli_initialisation() does load_file(), instead
	# of compile_file() :S:S
	_if !compiler_file! = !source_file! _andif
		(_not system.file_exists?(!source_file! + "c") _orif
   		(file_status.new(!source_file!).modify_time >
		 file_status.new(!source_file! + "c").modify_time))
	_then
		write("[INFO] compiling ", !source_file!)
		write("[INFO] this makes Smallworld's startup less verbose")
		compile_file(!source_file!)
	_endif
_endblock
$
